<!DOCTYPE html>
<html>
<head>
    <title>å’’è¯­å± é¾™æˆ˜-å®Œæ•´ä¿®å¤ç‰ˆ</title>
    <style>
        body {
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            padding: 20px;
        }

        #bossContainer {
            position: relative;
            width: 300px;
            margin: 20px auto;
        }

        #boss {
            font-size: 5em;
            margin: 20px 0;
            transform: scale(1);
            transition: all 0.3s;
        }

        .health-bar {
            width: 200px;
            height: 20px;
            background: #444;
            border-radius: 10px;
            margin: 0 auto;
            overflow: hidden;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(45deg, #ff0000 0%, #ff6a00 100%);
            width: 100%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #ff0000;
        }

        .word {
            display: inline-block;
            padding: 12px;
            margin: 8px;
            border: 2px solid #4a5568;
            border-radius: 8px;
            cursor: pointer;
            background: #2d3748;
            color: white;
            transition: all 0.2s;
        }

        .selected {
            background: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        #spellDialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 2px solid gold;
        }

        #battleLog {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 150px;
            background: rgba(0,0,0,0.8);
            color: #00ff00;
            padding: 10px;
            overflow-y: auto;
            border: 2px solid #00ff00;
            border-radius: 8px;
        }

        .spell-animation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            color: #ffeb3b;
            text-shadow: 0 0 10px #ff5722;
            animation: spellEffect 6s forwards;
            pointer-events: none;
        }

        @keyframes spellEffect {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
            5% { opacity: 1; transform: translate(-50%, -50%) scale(2); }
            90% { opacity: 1; transform: translate(-50%, -50%) scale(2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }

        button {
            padding: 12px 24px;
            font-size: 1.1em;
            background: #48bb78;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            transition: opacity 0.3s;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>æ¶é¾™è¡€é‡</h1>
    <div id="bossContainer">
        <div class="health-bar">
            <div class="health-fill" id="bossHealth" style="width: 100%"></div>
        </div>
        <div id="boss">ğŸ‰</div>
    </div>

    <div id="wordsContainer"></div>
    <button onclick="castSpell()" id="castButton">å‘åŠ¨å’’è¯­</button>
    <div>æ”»å‡»æ¬¡æ•°ï¼š<span id="attackCount">0</span>å‡»</div>

    <!-- å’’è¯­ç¡®è®¤å¼¹çª— -->
    <div id="spellDialog">
        <h2 id="spellName"></h2>
        <p id="spellPower"></p>
        <p id="spellDesc"></p>
        <button onclick="confirmSpell()">å‘åŠ¨ï¼</button>
        <button onclick="cancelSpell()">å–æ¶ˆ</button>
    </div>

    <div id="battleLog"></div>

    <script>
        // é…ç½®é¡¹ï¼ˆéœ€æ›¿æ¢ä¸ºçœŸå®å€¼ï¼‰
        const CONFIG = {
            API_ENDPOINT: 'https://yuanqi.tencent.com/openapi/v1/agent/chat/completions',
            ASSISTANT_ID: 'TRlr05PZe7n6',
            BEARER_TOKEN: 'MAN1ugTijvauHvKe3oPmZKXzu7Th2uhA',
            USER_ID: 'YOUR_USER_ID'
        };

        let gameState = {
            bossHp: 1000,
            attackCount: 0,
            selectedWords: [],
            isProcessing: false
        };

        // å…ƒç´ éªŒè¯
        function validateElements() {
            const requiredElements = [
                'spellName', 'spellPower', 'spellDesc',
                'attackCount', 'bossHealth', 'castButton',
                'wordsContainer', 'battleLog', 'boss'
            ];
            
            requiredElements.forEach(id => {
                if (!document.getElementById(id)) {
                    throw new Error(`å…³é”®å…ƒç´  #${id} åŠ è½½å¤±è´¥`);
                }
            });
        }

        class TencentAPI {
            static async callAgent(command) {
                try {
                    const response = await fetch(CONFIG.API_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'X-Source': 'openapi',
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${CONFIG.BEARER_TOKEN}`
                        },
                        body: JSON.stringify({
                            assistant_id: CONFIG.ASSISTANT_ID,
                            user_id: CONFIG.USER_ID,
                            stream: false,
                            messages: [{
                                role: "user",
                                content: [{ type: "text", text: command }]
                            }]
                        })
                    });

                    if (!response.ok) throw new Error(`APIé”™è¯¯: ${response.status}`);
                    const data = await response.json();
                    return this.parseResponse(data);
                } catch (error) {
                    console.error('APIè°ƒç”¨å¤±è´¥:', error);
                    throw error;
                }
            }

            static parseResponse(data) {
                try {
                    const content = data.choices[0].message.content;
                    const jsonString = content.match(/```json\n([\s\S]*?)\n```/)?.[1] || content;
                    return JSON.parse(jsonString);
                } catch (e) {
                    throw new Error('å“åº”è§£æå¤±è´¥');
                }
            }
        }

        class GameController {
            static async initialize() {
                validateElements();
                await this.generateNewWords();
            }

            static async generateNewWords() {
                try {
                    toggleProcessing(true);
                    const { words } = await TencentAPI.callAgent("ç”Ÿæˆæ–‡å­—");
                    renderWords(words);
                } catch (error) {
                    showError('ç”Ÿæˆæ–‡å­—å¤±è´¥ï¼Œè¯·é‡è¯•');
                } finally {
                    toggleProcessing(false);
                }
            }

            static async evaluateSpell() {
                const spellName = gameState.selectedWords.join('');
                const result = await TencentAPI.callAgent(`å¨åŠ›è¯„ä¼°ï¼š${spellName}`);
                
                if (!result.power || !result.desc || !result.words) {
                    throw new Error('æ— æ•ˆçš„APIå“åº”');
                }
                
                return {
                    power: Math.min(999, result.power),
                    desc: result.desc,
                    words: result.words.replace(/\$\{words\}/g, spellName)
                };
            }
        }

        // UIäº¤äº’å‡½æ•°
        function toggleWord(word, element) {
            if (gameState.isProcessing) return;
            
            const index = gameState.selectedWords.indexOf(word);
            if (index === -1) {
                gameState.selectedWords.push(word);
                element.classList.add('selected');
            } else {
                gameState.selectedWords.splice(index, 1);
                element.classList.remove('selected');
            }
        }

        async function castSpell() {
            if (gameState.isProcessing || gameState.selectedWords.length === 0) return;
            
            try {
                gameState.isProcessing = true;
                const { power, desc, words } = await GameController.evaluateSpell();

                // æ˜¾ç¤ºå¼¹çª—
                showSpellDialog(power, desc, gameState.selectedWords.join(''));

                // ç­‰å¾…ç”¨æˆ·ç¡®è®¤
                const confirmed = await new Promise(resolve => {
                    window.confirmSpell = () => resolve(true);
                    window.cancelSpell = () => resolve(false);
                });

                document.getElementById('spellDialog').style.display = 'none';
                if (!confirmed) return;

                // æ‰§è¡Œæ”»å‡»
                executeAttack(power, words);
                
                // Bossåå‡»
                if (gameState.bossHp > 0) {
                    setTimeout(bossCounterAttack, 1000);
                }

                // åˆ·æ–°æ–‡å­—
                await GameController.generateNewWords();

            } catch (error) {
                showError('å’’è¯­å‘åŠ¨å¤±è´¥: ' + error.message);
            } finally {
                gameState.isProcessing = false;
            }
        }

        function showSpellDialog(power, desc, spellName) {
            const dialog = document.getElementById('spellDialog');
            if (!dialog) throw new Error('å¼¹çª—ç»„ä»¶æœªæ‰¾åˆ°');

            dialog.querySelector('#spellName').textContent = spellName;
            dialog.querySelector('#spellPower').textContent = `å¨åŠ›: ${power}`;
            dialog.querySelector('#spellDesc').textContent = desc;
            dialog.style.display = 'block';
        }

        function executeAttack(power, words) {
            // æ˜¾ç¤ºæ”»å‡»åŠ¨ç”»
            const anim = document.createElement('div');
            anim.className = 'spell-animation';
            anim.textContent = words;
            document.body.appendChild(anim);
            setTimeout(() => anim.remove(), 1000);

            // æ›´æ–°çŠ¶æ€
            gameState.attackCount++;
            gameState.bossHp = Math.max(0, gameState.bossHp - power);
            
            // æ›´æ–°UI
            document.getElementById('attackCount').textContent = gameState.attackCount;
            document.getElementById('bossHealth').style.width = `${(gameState.bossHp / 1000) * 100}%`;
            
            // Bosså—å‡»åŠ¨ç”»
            const boss = document.getElementById('boss');
            boss.style.transform = 'scale(1.2)';
            setTimeout(() => boss.style.transform = 'scale(1)', 300);

            // æˆ˜æ–—æ—¥å¿—
            logAction(`âœ¨ å‘åŠ¨å’’è¯­ï¼š${words}ï¼ˆé€ æˆ${power}ç‚¹ä¼¤å®³ï¼‰`);

            // èƒœåˆ©åˆ¤æ–­
            if (gameState.bossHp === 0) {
                setTimeout(() => alert(`èƒœåˆ©ï¼${gameState.attackCount}æ¬¡æ”»å‡»å‡»è´¥æ¶é¾™ï¼`), 500);
            }
        }

        function bossCounterAttack() {
            const damage = Math.floor(Math.random() * 50) + 30;
            logAction(`ğŸ‰ æ¶é¾™åå‡»ï¼é€ æˆ${damage}ç‚¹ä¼¤å®³`);
        }

        function renderWords(words) {
            const container = document.getElementById('wordsContainer');
            container.innerHTML = words.map(word => `
                <div class="word" onclick="toggleWord('${word}', this)">
                    ${word}
                </div>
            `).join('');
            gameState.selectedWords = [];
        }

        function logAction(text) {
            const log = document.getElementById('battleLog');
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${text}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function toggleProcessing(isProcessing) {
            document.getElementById('castButton').disabled = isProcessing;
        }

        function showError(message) {
            logAction(`âŒ é”™è¯¯ï¼š${message}`);
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        window.onload = () => {
            try {
                validateElements();
                GameController.initialize();
            } catch (error) {
                alert('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        }
    </script>
</body>
</html>